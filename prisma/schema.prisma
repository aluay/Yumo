datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

/// ----------  USER  ----------
model User {
  id            Int       @id @default(autoincrement())
  name          String
  email         String    @unique
  emailVerified DateTime?
  image         String

  // Profile fields
  website     String?
  bio         String?
  pageContent Json?

  accounts      Account[]
  sessions      Session[]
  posts         Post[]
  comments      Comment[]
  postLikes     PostLike[]
  postBookmarks PostBookmark[]

  commentLikes    CommentLike[]
  commentReports  CommentReport[]
  Activity        Activity[]
  ActivityMention ActivityMention[]
  Notification    Notification[]
  tagFollows      TagFollow[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

/// ----------  ACCOUNT  ----------
model Account {
  id                Int     @id @default(autoincrement())
  userId            Int
  type              String
  provider          String
  providerAccountId String  @unique
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id])

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

/// ----------  POST  ----------
model Post {
  id          Int        @id @default(autoincrement())
  title       String
  description String
  content     Json // TipTap JSON
  tags        String[]
  status      PostStatus @default(PUBLISHED)

  // denormalised stats – cheap sort/filter
  likeCount     Int @default(0)
  bookmarkCount Int @default(0)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // soft‑delete keeps comments alive

  /**
   * ─── relations ────────────────────────────────────────────
   */
  authorId Int
  author   User @relation(fields: [authorId], references: [id])

  comments  Comment[]
  likes     PostLike[]
  bookmarks PostBookmark[]

  Activity Activity[]

  @@index([status, createdAt])
}

/// Post status
enum PostStatus {
  DRAFT
  PUBLISHED
}

/// Like toggle table
model PostLike {
  userId    Int
  postId    Int
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, postId]) // one like per user
}

/// Bookmark toggle table
model PostBookmark {
  userId    Int
  postId    Int
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, postId])
}

/// ----------  COMMENTS  ----------
model Comment {
  id        Int       @id @default(autoincrement())
  postId    Int
  parentId  Int?
  authorId  Int
  content   Json
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // preserves thread shape

  // counters
  likeCount   Int @default(0)
  replyCount  Int @default(0)
  reportCount Int @default(0)

  /**
   * ─── relations ────────────────────────────────────────────
   */
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  author User @relation(fields: [authorId], references: [id])

  parent  Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies Comment[] @relation("CommentReplies")

  likes   CommentLike[]
  reports CommentReport[]

  @@index([postId, createdAt])
}

/// Like toggle for comments
model CommentLike {
  userId    Int
  commentId Int
  createdAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, commentId])
}

/// Abuse / report
model CommentReport {
  id        Int      @id @default(autoincrement())
  userId    Int
  commentId Int
  reason    String   @db.VarChar(255)
  createdAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId]) // one report per user
}

model Activity {
  id         Int          @id @default(autoincrement())
  userId     Int
  type       ActivityType
  targetId   Int
  targetType TargetType
  message    String?
  createdAt  DateTime     @default(now())

  user User @relation(fields: [userId], references: [id])

  /**
   * reverse navigation for notifications & mentions *
   */
  mentions      ActivityMention[]
  notifications Notification[]
  Post          Post?             @relation(fields: [postId], references: [id])
  postId        Int?
}

model ActivityMention {
  id         Int      @id @default(autoincrement())
  activityId Int
  userId     Int
  createdAt  DateTime @default(now())

  activity Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([activityId, userId]) // no dupes
}

enum ActivityType {
  POST_CREATED
  POST_LIKED
  POST_BOOKMARKED
  COMMENT_POSTED
  COMMENT_LIKED
  USER_MENTIONED
}

enum TargetType {
  POST
  COMMENT
  USER // e.g., follow
}

model Notification {
  id          Int       @id @default(autoincrement())
  recipientId Int
  activityId  Int
  isRead      Boolean   @default(false)
  createdAt   DateTime  @default(now())
  readAt      DateTime?

  recipient User     @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  activity  Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@unique([recipientId, activityId]) // 1 notification per user per activity
  @@index([recipientId, isRead])
}

/// ----------  TAG FOLLOWS  ----------
model TagFollow {
  userId    Int
  tag       String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, tag]) // composite primary key - one follow per tag per user
  @@index([tag]) // for efficient lookup by tag
}
